<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Quiz JS : Pure Functions, Destructuring & Immutabilit√©</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<div id="navigation"></div>

<h1>Quiz JS : Pure Functions, Destructuring & Immutabilit√© ++</h1>
<p>Compl√®te ce que la console afficherait ou indique la valeur finale. Clique sur "Valider".</p>

<div id="quizContainer"></div>

<script>
const quizData = [
  // ===== Pure functions & Side Effects =====
  {
    id: "side-1",
    titre: "1Ô∏è‚É£ Pure function simple",
    code: `function add(a, b) { return a + b; }
console.log(add(2, 3));`,
    reponse: ["5"],
    explication: "La fonction ne modifie aucune variable externe et retourne toujours le m√™me r√©sultat pour les m√™mes param√®tres."
  },

  {
    id: "side-2",
    titre: "2Ô∏è‚É£ Fonction avec side effect",
    code: `let x = 1;
function increment() { x++; }
increment();
console.log(x);`,
    reponse: ["2"],
    explication: "La fonction modifie une variable externe ‚Üí side effect."
  },

  {
    id: "side-3",
    titre: "3Ô∏è‚É£ Pure function vs side effect",
    code: `let y = 10;
function pureAdd(a, b) { return a + b; }
function impureAdd(a, b) { y += a + b; return y; }
console.log(pureAdd(2,3), impureAdd(2,3));`,
    reponse: ["5","15"],
    explication: "pureAdd est pure, impureAdd modifie y ‚Üí side effect."
  },

  // ===== Destructuring & Spread/Rest =====
  {
    id: "side-4",
    titre: "4Ô∏è‚É£ Destructuring objet",
    code: `const user = {name: 'Alice', age: 25};
const {name, age} = user;
console.log(name, age);`,
    reponse: ["Alice","25"],
    explication: "Destructuring permet de cr√©er des variables directement depuis les propri√©t√©s de l'objet."
  },

  {
    id: "side-5",
    titre: "5Ô∏è‚É£ Destructuring tableau",
    code: `const nums = [1,2,3];
const [a,,c] = nums;
console.log(a, c);`,
    reponse: ["1","3"],
    explication: "On peut sauter des √©l√©ments avec des virgules."
  },

  {
    id: "side-6",
    titre: "6Ô∏è‚É£ Spread operator pour copier",
    code: `const arr1 = [1,2];
const arr2 = [...arr1,3];
console.log(arr2);`,
    reponse: ["1,2,3"],
    explication: "Spread operator permet de copier un tableau et ajouter des √©l√©ments."
  },

  {
    id: "side-7",
    titre: "7Ô∏è‚É£ Rest operator dans fonction",
    code: `function sum(...nums) { return nums.reduce((a,b) => a+b,0); }
console.log(sum(1,2,3,4));`,
    reponse: ["10"],
    explication: "Rest operator rassemble tous les arguments restants dans un tableau."
  },

  // ===== Immutabilit√© & State Management =====
  {
    id: "side-8",
    titre: "8Ô∏è‚É£ Immutabilit√© tableau",
    code: `const arr = [1,2,3];
const newArr = arr.map(x => x*2);
console.log(arr);
console.log(newArr);`,
    reponse: ["1,2,3","2,4,6"],
    explication: "map retourne un nouveau tableau, l'original reste inchang√© ‚Üí immutabilit√©."
  },

  {
    id: "side-9",
    titre: "9Ô∏è‚É£ Immutabilit√© objet",
    code: `const user = {name: 'Bob', age: 30};
const updatedUser = {...user, age: 31};
console.log(user.age, updatedUser.age);`,
    reponse: ["30","31"],
    explication: "Spread operator permet de cr√©er un nouvel objet avec des modifications sans changer l'original."
  },

  {
    id: "side-10",
    titre: "üîü State management simple",
    code: `let state = {count: 0};
function increment(state) {
  return {...state, count: state.count+1};
}
state = increment(state);
console.log(state.count);`,
    reponse: ["1"],
    explication: "On retourne un nouvel objet pour garder l'√©tat immuable."
  },

  {
    id: "side-11",
    titre: "1Ô∏è‚É£1Ô∏è‚É£ Side effect cach√©",
    code: `let total = 0;
function addToTotal(x) { total += x; return total; }
console.log(addToTotal(5));
console.log(addToTotal(3));`,
    reponse: ["5","8"],
    explication: "La fonction modifie une variable externe ‚Üí side effect, r√©sultat d√©pend de l'√©tat pr√©c√©dent."
  },

  {
    id: "side-12",
    titre: "1Ô∏è‚É£2Ô∏è‚É£ Combinaison destructuring & immutabilit√©",
    code: `const user = {name: 'Eve', scores: [10,20]};
const {scores} = user;
const newScores = [...scores,30];
console.log(scores);
console.log(newScores);`,
    reponse: ["10,20","10,20,30"],
    explication: "On ne modifie pas le tableau original, on cr√©e un nouveau ‚Üí immutabilit√©."
  },

  // ===== Plus d'exemples Pure Functions & Side Effects =====
  {
    id: "side-13",
    titre: "1Ô∏è‚É£3Ô∏è‚É£ Fonction pure avec objet",
    code: `function createUser(name, age) {
  return {name, age, id: Math.random()};
}
const user1 = createUser('Alice', 25);
const user2 = createUser('Alice', 25);
console.log(user1 === user2);`,
    reponse: ["false"],
    explication: "M√™me si les param√®tres sont identiques, Math.random() cr√©e des objets diff√©rents ‚Üí fonction pure mais r√©sultat diff√©rent."
  },

  {
    id: "side-14",
    titre: "1Ô∏è‚É£4Ô∏è‚É£ Side effect avec console.log",
    code: `function impureLog(x) {
  console.log('Calcul en cours...');
  return x * 2;
}
const result = impureLog(5);
console.log(result);`,
    reponse: ["Calcul en cours...","10"],
    explication: "console.log est un side effect car cela interagit avec l'environnement externe."
  },

  {
    id: "side-15",
    titre: "1Ô∏è‚É£5Ô∏è‚É£ Fonction pure vs impure avec Date",
    code: `function pureGetTime() {
  return new Date().getTime();
}
function impureGetTime() {
  const now = new Date().getTime();
  console.log('Timestamp:', now);
  return now;
}
console.log(pureGetTime() === pureGetTime());`,
    reponse: ["false"],
    explication: "M√™me les fonctions 'pures' avec Date() ne sont pas vraiment pures car le temps change."
  },

  {
    id: "side-16",
    titre: "1Ô∏è‚É£6Ô∏è‚É£ Fonction avec closure et side effect",
    code: `function createCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}
const counter = createCounter();
console.log(counter(), counter());`,
    reponse: ["1","2"],
    explication: "La closure maintient l'√©tat entre les appels ‚Üí side effect cach√©."
  },

  {
    id: "side-17",
    titre: "1Ô∏è‚É£7Ô∏è‚É£ Fonction pure avec array methods",
    code: `const numbers = [1,2,3,4,5];
function getEvenNumbers(arr) {
  return arr.filter(x => x % 2 === 0);
}
const evens = getEvenNumbers(numbers);
console.log(numbers);
console.log(evens);`,
    reponse: ["1,2,3,4,5","2,4"],
    explication: "filter() retourne un nouveau tableau, ne modifie pas l'original ‚Üí fonction pure."
  },

  // ===== Plus d'exemples Destructuring & Spread/Rest =====
  {
    id: "side-18",
    titre: "1Ô∏è‚É£8Ô∏è‚É£ Destructuring avec valeurs par d√©faut",
    code: `const user = {name: 'Bob'};
const {name, age = 25, city = 'Paris'} = user;
console.log(name, age, city);`,
    reponse: ["Bob","25","Paris"],
    explication: "On peut d√©finir des valeurs par d√©faut lors du destructuring."
  },

  {
    id: "side-19",
    titre: "1Ô∏è‚É£9Ô∏è‚É£ Destructuring avec renommage",
    code: `const person = {firstName: 'Alice', lastName: 'Smith'};
const {firstName: prenom, lastName: nom} = person;
console.log(prenom, nom);`,
    reponse: ["Alice","Smith"],
    explication: "On peut renommer les propri√©t√©s lors du destructuring avec la syntaxe 'ancien: nouveau'."
  },

  {
    id: "side-20",
    titre: "2Ô∏è‚É£0Ô∏è‚É£ Destructuring de tableau avec rest",
    code: `const numbers = [1,2,3,4,5];
const [first, second, ...rest] = numbers;
console.log(first, second, rest);`,
    reponse: ["1","2","3,4,5"],
    explication: "Le rest operator dans le destructuring collecte les √©l√©ments restants."
  },

  {
    id: "side-21",
    titre: "2Ô∏è‚É£1Ô∏è‚É£ Destructuring d'objet avec rest",
    code: `const user = {name: 'Eve', age: 30, city: 'Lyon', country: 'France'};
const {name, ...details} = user;
console.log(name, details);`,
    reponse: ["Eve","[object Object]"],
    explication: "Le rest operator collecte les propri√©t√©s restantes dans un objet."
  },

  {
    id: "side-22",
    titre: "2Ô∏è‚É£2Ô∏è‚É£ Spread pour fusionner des objets",
    code: `const user = {name: 'Alice', age: 25};
const address = {city: 'Paris', country: 'France'};
const profile = {...user, ...address, verified: true};
console.log(profile);`,
    reponse: ["[object Object]"],
    explication: "Spread permet de fusionner plusieurs objets en un seul."
  },

  {
    id: "side-23",
    titre: "2Ô∏è‚É£3Ô∏è‚É£ Spread pour passer des arguments",
    code: `function multiply(a, b, c) {
  return a * b * c;
}
const numbers = [2, 3, 4];
console.log(multiply(...numbers));`,
    reponse: ["24"],
    explication: "Spread permet de d√©composer un tableau en arguments individuels."
  },

  {
    id: "side-24",
    titre: "2Ô∏è‚É£4Ô∏è‚É£ Rest dans les param√®tres de fonction",
    code: `function greet(greeting, ...names) {
  return names.map(name => \`\${greeting} \${name}\`).join(', ');
}
console.log(greet('Bonjour', 'Alice', 'Bob', 'Charlie'));`,
    reponse: ["Bonjour Alice, Bonjour Bob, Bonjour Charlie"],
    explication: "Rest collecte tous les arguments restants dans un tableau."
  },

  // ===== Plus d'exemples Immutabilit√© & State Management =====
  {
    id: "side-25",
    titre: "2Ô∏è‚É£5Ô∏è‚É£ Immutabilit√© avec objets imbriqu√©s",
    code: `const user = {name: 'Alice', address: {city: 'Paris', zip: 75001}};
const newUser = {...user, address: {...user.address, zip: 75002}};
console.log(user.address.zip, newUser.address.zip);`,
    reponse: ["75001","75002"],
    explication: "Pour les objets imbriqu√©s, il faut copier chaque niveau pour maintenir l'immutabilit√©."
  },

  {
    id: "side-26",
    titre: "2Ô∏è‚É£6Ô∏è‚É£ Immutabilit√© avec tableaux imbriqu√©s",
    code: `const matrix = [[1,2], [3,4]];
const newMatrix = matrix.map(row => [...row]);
newMatrix[0][0] = 99;
console.log(matrix[0][0], newMatrix[0][0]);`,
    reponse: ["1","99"],
    explication: "Pour les tableaux imbriqu√©s, il faut copier chaque niveau pour √©viter les mutations."
  },

  {
    id: "side-27",
    titre: "2Ô∏è‚É£7Ô∏è‚É£ State management avec actions",
    code: `let state = {count: 0, user: 'Guest'};
function reducer(state, action) {
  switch(action.type) {
    case 'INCREMENT': return {...state, count: state.count + 1};
    case 'SET_USER': return {...state, user: action.payload};
    default: return state;
  }
}
state = reducer(state, {type: 'INCREMENT'});
state = reducer(state, {type: 'SET_USER', payload: 'Alice'});
console.log(state.count, state.user);`,
    reponse: ["1","Alice"],
    explication: "Pattern reducer pour g√©rer l'√©tat de mani√®re pr√©visible et immuable."
  },

  {
    id: "side-28",
    titre: "2Ô∏è‚É£8Ô∏è‚É£ Immutabilit√© avec Object.freeze",
    code: `const config = Object.freeze({api: 'https://api.com', timeout: 5000});
try {
  config.timeout = 3000;
} catch(e) {}
console.log(config.timeout);`,
    reponse: ["5000"],
    explication: "Object.freeze emp√™che la modification des propri√©t√©s d'un objet."
  },

  {
    id: "side-29",
    titre: "2Ô∏è‚É£9Ô∏è‚É£ Immutabilit√© avec array methods",
    code: `const numbers = [1,2,3,4,5];
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x > 2);
const reduced = numbers.reduce((acc, x) => acc + x, 0);
console.log(numbers, doubled, filtered, reduced);`,
    reponse: ["1,2,3,4,5","2,4,6,8,10","3,4,5","15"],
    explication: "Les m√©thodes fonctionnelles retournent de nouveaux tableaux sans modifier l'original."
  },

  {
    id: "side-30",
    titre: "3Ô∏è‚É£0Ô∏è‚É£ State management complexe",
    code: `let appState = {
  users: [{id: 1, name: 'Alice'}],
  currentUser: null,
  loading: false
};

function addUser(state, user) {
  return {
    ...state,
    users: [...state.users, {...user, id: Date.now()}]
  };
}

function setCurrentUser(state, user) {
  return {...state, currentUser: user};
}

appState = addUser(appState, {name: 'Bob'});
appState = setCurrentUser(appState, appState.users[1]);
console.log(appState.users.length, appState.currentUser.name);`,
    reponse: ["2","Bob"],
    explication: "Gestion d'√©tat complexe avec plusieurs propri√©t√©s, toutes immuables."
  },

  // ===== Sc√©narios avanc√©s combinant plusieurs concepts =====
  {
    id: "side-31",
    titre: "3Ô∏è‚É£1Ô∏è‚É£ Fonction pure avec destructuring et spread",
    code: `function updateUser({name, age, ...rest}, updates) {
  return {...rest, name, age, ...updates};
}
const user = {name: 'Alice', age: 25, city: 'Paris'};
const updated = updateUser(user, {age: 26, verified: true});
console.log(user.age, updated.age, updated.verified);`,
    reponse: ["25","26","true"],
    explication: "Fonction pure utilisant destructuring pour extraire des propri√©t√©s et spread pour les fusionner."
  },

  {
    id: "side-32",
    titre: "3Ô∏è‚É£2Ô∏è‚É£ Immutabilit√© avec destructuring et side effects",
    code: `let globalState = {items: [], total: 0};
function addItem(state, item) {
  const newState = {
    ...state,
    items: [...state.items, item],
    total: state.total + item.price
  };
  globalState = newState; // Side effect
  return newState;
}
const result = addItem(globalState, {name: 'Laptop', price: 1000});
console.log(globalState.total, result.total);`,
    reponse: ["1000","1000"],
    explication: "M√™me avec un side effect, la fonction retourne un nouvel √©tat immuable."
  },

  {
    id: "side-33",
    titre: "3Ô∏è‚É£3Ô∏è‚É£ Rest et spread avec fonctions pures",
    code: `function processData(...data) {
  return data
    .filter(x => x > 0)
    .map(x => x * 2)
    .reduce((acc, x) => acc + x, 0);
}
const numbers = [1, -2, 3, -4, 5];
const result = processData(...numbers);
console.log(result);`,
    reponse: ["18"],
    explication: "Fonction pure utilisant rest pour collecter les arguments et spread pour les passer."
  },

  {
    id: "side-34",
    titre: "3Ô∏è‚É£4Ô∏è‚É£ State management avec destructuring et immutabilit√©",
    code: `const initialState = {users: [], selectedUser: null, filters: {}};
function userReducer(state, action) {
  const {type, payload} = action;
  switch(type) {
    case 'ADD_USER':
      return {...state, users: [...state.users, payload]};
    case 'SELECT_USER':
      return {...state, selectedUser: payload};
    case 'SET_FILTER':
      return {...state, filters: {...state.filters, ...payload}};
    default:
      return state;
  }
}
let state = userReducer(initialState, {type: 'ADD_USER', payload: {id: 1, name: 'Alice'}});
state = userReducer(state, {type: 'SELECT_USER', payload: 1});
console.log(state.users.length, state.selectedUser);`,
    reponse: ["1","1"],
    explication: "Reducer complexe utilisant destructuring pour extraire type et payload, avec √©tat immuable."
  },

  {
    id: "side-35",
    titre: "3Ô∏è‚É£5Ô∏è‚É£ Fonction impure avec destructuring et side effects",
    code: `let cache = {};
function memoizedAdd(a, b) {
  const key = \`\${a}-\${b}\`;
  if (cache[key]) {
    console.log('Cache hit!');
    return cache[key];
  }
  const result = a + b;
  cache[key] = result; // Side effect
  console.log('Calculated:', result);
  return result;
}
console.log(memoizedAdd(2, 3));
console.log(memoizedAdd(2, 3));`,
    reponse: ["Calculated: 5","Cache hit!","5"],
    explication: "Fonction avec side effect (cache) utilisant destructuring pour les param√®tres."
  }
];

</script>

<script src="quiz-common.js"></script>
<script>
// Initialiser le quiz avec les fonctions communes
const quiz = new QuizManager('quizContainer', quizData);
</script>

<script src="navigation.js"></script>
<script>
  // Initialiser la navigation pour la page Side Effects
  createNavigation('side');
</script>

</body>
</html>
