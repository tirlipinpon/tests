<!DOCTYPE html> 
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Quiz Expert TypeScript - Types Avancés & Architecture</title>
<link rel="stylesheet" href="styles.css">
</head>
<body>

<header>
  <div id="navigation"></div>
  <h1>Quiz Expert : TypeScript - Types Avancés & Architecture</h1>
  <p class="lead">Mix QCM (choix unique ou multiple) + réponses libres. Options mélangées aléatoirement. Clique sur "Valider" pour obtenir le feedback.</p>
</header>

<div id="quizContainer"></div>

<script>
// --- Données du quiz ---
const quizData = [
  {
    id: "typescript-1",
    titre: "1️⃣ Rôle des Types Conditionnels",
    code: "Quel est le rôle principal des Types Conditionnels en TypeScript ?",
    options: [
      "Ils permettent de définir des types récursifs uniquement.",
      "Ils permettent de créer des transformations de types basées sur une logique conditionnelle (si/alors/sinon).",
      "Ils servent uniquement à garantir l'immutabilité des propriétés d'un objet."
    ],
    reponse: "Ils permettent de créer des transformations de types basées sur une logique conditionnelle (si/alors/sinon).",
    type: "qcm",
    explication: "Les Types Conditionnels (Conditional Types) permettent aux développeurs de créer des transformations de types basées sur une logique conditionnelle [1, 2]. Ils définissent des types qui dépendent de la structure d'autres types, offrant ainsi flexibilité et adaptabilité [1]. La syntaxe utilisée est similaire à celle des expressions ternaires (`T extends U ? X : Y`) [1, 3]."
  },
  {
    id: "typescript-2",
    titre: "2️⃣ Mot-clé d'inférence de Type",
    code: "Quel mot-clé est utilisé dans un Type Conditionnel pour extraire un type (par exemple, le type du premier argument d'une fonction) dans la branche 'true' de la condition ?",
    options: [],
    reponse: "infer",
    type: "input",
    explication: "Le mot-clé `infer` est utilisé au sein des Types Conditionnels pour inférer le type d'une variable ou d'un composant de type, comme dans l'exemple `FirstArgument<T>` qui extrait le type du premier argument d'une fonction fournie `T` [4]."
  },
  {
    id: "typescript-3",
    titre: "3️⃣ Itération des propriétés avec Types Mappés",
    code: "Dans la syntaxe d'un Type Mappé en TypeScript : \n`type MappedType<T> = { [K in keyof T]: /* transformation logic */; };`\n Quel est le rôle de `[K in keyof T]` ?",
    options: [
      "Déclarer que le nouveau type est récursif.",
      "Transformer les types de propriétés pour qu'ils deviennent des types littéraux de modèle.",
      "Itérer sur chaque propriété de l'original type `T`, où `K` représente les clés (propriétés) du type original."
    ],
    reponse: "Itérer sur chaque propriété de l'original type `T`, où `K` représente les clés (propriétés) du type original.",
    type: "qcm",
    explication: "Les Types Mappés (Mapped Types) fournissent un moyen concis de transformer les propriétés des types existants [3, 5]. La syntaxe `[K in keyof T]` itère sur chaque propriété du type original `T`, où `keyof T` représente l'union de tous les noms de propriétés de `T` [6, 7]."
  },
  {
    id: "typescript-4",
    titre: "4️⃣ Compilation V8 JIT",
    code: "Quel composant du moteur V8 est spécifiquement responsable de l'optimisation des chemins de code fréquemment exécutés (code 'hot') en compilant le bytecode en code machine hautement optimisé ?",
    options: [
      "Ignition",
      "Turbofan",
      "Abstract Syntax Tree (AST)"
    ],
    reponse: "Turbofan",
    type: "qcm",
    explication: "Le moteur V8 utilise l'interpréteur **Ignition** pour générer du bytecode à partir de l'AST. Cependant, les chemins de code fréquemment exécutés sont identifiés et optimisés par le compilateur JIT **Turbofan**, qui compile le bytecode en code machine hautement optimisé [8]."
  },
  {
    id: "typescript-5",
    titre: "5️⃣ Patron d'Événement Asynchrone",
    code: "Quel patron d'architecture permet aux composants de s'abonner et de recevoir des mises à jour de 'publishers', améliorant ainsi la modularité et réduisant les dépendances entre eux ?",
    options: [
      "Le Patron Modèle-Vue-Contrôleur (MVC)",
      "Le Patron Client-Serveur",
      "Le Patron Publisher-Subscriber (Éditeur-Abonné)"
    ],
    reponse: "Le Patron Publisher-Subscriber (Éditeur-Abonné)",
    type: "qcm",
    explication: "Le Patron Publisher-Subscriber permet aux composants de souscrire aux mises à jour et de les recevoir des éditeurs (publishers), ce qui améliore la modularité et réduit les dépendances en découplant les composants [9]."
  },
  {
    id: "typescript-6",
    titre: "6️⃣ Logique Métier MVC",
    code: "Dans le patron Modèle-Vue-Contrôleur (MVC), quel composant est responsable de l'encapsulation de la logique métier (business logic) et de la gestion des entrées utilisateur ?",
    options: [],
    reponse: "Controller",
    type: "input",
    explication: "Le patron MVC sépare l'application en trois composants interconnectés : le Modèle (données), la Vue (interface utilisateur) et le **Contrôleur** (logique métier). Cette séparation améliore la maintenabilité et la testabilité [10]."
  },
  {
    id: "typescript-7",
    titre: "7️⃣ Rendre les propriétés Optionnelles",
    code: "Quel type utilitaire intégré de TypeScript permet de rendre toutes les propriétés d'un type existant optionnelles ?",
    options: [
      "Required<T>",
      "Readonly<T>",
      "Partial<T>"
    ],
    reponse: "Partial<T>",
    type: "qcm",
    explication: "Le type utilitaire `Partial<T>` est un type mappé qui rend toutes les propriétés du type `T` optionnelles. Inversement, `Required<T>` rend toutes les propriétés requises, et `Readonly<T>` les rend immuables [11, 12]."
  },
  {
    id: "typescript-8",
    titre: "8️⃣ Cause de Fuite de Mémoire (DOM)",
    code: "Parmi les causes de fuite de mémoire en JavaScript, laquelle est directement liée au fait d'oublier de retirer des références à des éléments DOM devenus inutiles ?",
    options: [
      "L'utilisation excessive de `let`.",
      "Les Références Circulaires.",
      "Les Écouteurs d'Événements (Event Listeners) non fermés."
    ],
    reponse: "Les Écouteurs d'Événements (Event Listeners) non fermés.",
    type: "qcm",
    explication: "Oublier de supprimer les écouteurs d'événements peut entraîner des fuites de mémoire, car ces écouteurs conservent des références aux éléments DOM, empêchant la collecte des objets inutilisés par le ramasse-miettes [13]. Il est recommandé d'utiliser `removeEventListener` lorsque l'écouteur n'est plus nécessaire [14]."
  },
  {
    id: "typescript-9",
    titre: "9️⃣ Rôle du Patron Pipe-Filter",
    code: "Décrivez le rôle du patron Pipe-Filter dans une application.",
    options: [
      "Il gère la réplication des données pour la tolérance aux pannes.",
      "Il sépare les opérations de lecture et d'écriture des données (Query et Command).",
      "Il assemble un pipeline de filtres pour traiter et transformer des données par étapes consécutives."
    ],
    reponse: "Il assemble un pipeline de filtres pour traiter et transformer des données par étapes consécutives.",
    type: "qcm",
    explication: "Le patron Pipe-Filter (ou Pipeline) est conçu pour traiter et transformer des données en les faisant passer par une série de composants de filtre, chacun effectuant une tâche spécifique sur les données [15]."
  },
  {
    id: "typescript-10",
    titre: "10️⃣ Composant fondamental du DDD",
    code: "Dans le Domain-Driven Design (DDD), quel terme désigne les objets qui possèdent une signification importante dans le domaine d'intérêt et servent de principaux blocs de construction pour les modèles d'entreprise ?",
    options: [],
    reponse: "Entités",
    type: "input",
    explication: "Les **entités** (entities) sont les principaux blocs de construction pour les modèles d'entreprise en DDD. Ce sont des objets qui ont une signification importante dans le domaine d'intérêt [16]."
  },
  {
    id: "typescript-11",
    titre: "11️⃣ Objectif des Type Guards",
    code: "Quel est l'objectif des Type Guards (ou gardes de type) en TypeScript ?",
    options: [
      "Permettre l'utilisation de types récursifs dans les interfaces.",
      "Restreindre (narrow down) le type d'une variable au sein d'un bloc de code, améliorant ainsi la sécurité des types.",
      "Créer une nouvelle instance d'une classe de manière sécurisée."
    ],
    reponse: "Restreindre (narrow down) le type d'une variable au sein d'un bloc de code, améliorant ainsi la sécurité des types.",
    type: "qcm",
    explication: "Les Type Guards facilitent la protection des types pour restreindre les types basés sur des vérifications au moment de l'exécution, améliorant la sécurité des types dans des blocs de code spécifiques (par exemple, dans un bloc `if` ou `switch`) [17-19]."
  },
  {
    id: "typescript-12",
    titre: "12️⃣ Technique de Garbage Collection",
    code: "Comment s'appelle l'approche de collecte de mémoire la plus courante en JavaScript, qui commence par un ensemble d'objets racine et parcourt le graphe d'objets pour identifier ceux qui sont atteignables, avant de libérer l'espace des objets non marqués ?",
    options: [],
    reponse: "Mark and Sweep",
    type: "input",
    explication: "Le moteur JavaScript utilise plusieurs techniques de collecte des déchets, la plus populaire étant l'approche **Mark and Sweep** (Marquage et Balayage) [20]. Le processus de Marquage identifie tous les objets atteignables à partir des racines, tandis que le Balayage libère la mémoire utilisée par les objets non marqués [20]."
  },
  {
    id: "typescript-13",
    titre: "13️⃣ Proxy vs Decorator",
    code: "Quelle est la différence fondamentale de responsabilité entre le Proxy Pattern et le Decorator Pattern, en ce qui concerne l'interface de l'objet enveloppé ?",
    options: [
      "Le Proxy est conçu pour retourner la même interface, tandis que le Decorator améliore l'interface.",
      "Le Decorator est utilisé pour l'accès aux données, tandis que le Proxy sert uniquement à la validation.",
      "Le Proxy ne peut pas ajouter de logique personnalisée, alors que le Decorator le peut."
    ],
    reponse: "Le Proxy est conçu pour retourner la même interface, tandis que le Decorator améliore l'interface.",
    type: "qcm",
    explication: "Le patron Proxy est généralement destiné à renvoyer la *même interface*, de sorte que le client suppose qu'il travaille avec le même objet intact. Le Decorator, en revanche, a pour responsabilité principale d'améliorer l'objet qu'il enveloppe, et peut retourner une interface améliorée dont le client peut être conscient [21, 22]."
  },
  {
    id: "typescript-14",
    titre: "14️⃣ Opération de Lecture CQRS",
    code: "Dans le patron Command Query Responsibility Segregation (CQRS), quelle partie de la ségrégation est associée à l'opération de lecture des données ?",
    options: [],
    reponse: "Query",
    type: "input",
    explication: "Le patron CQRS sépare les opérations de lecture (`Query`) et d'écriture (`Command`), optimisant ainsi le système pour la performance et l'évolutivité. `Query` est l'opération de lecture [23]."
  },
  {
    id: "typescript-15",
    titre: "15️⃣ Outil de Monorepo Populaire",
    code: "Quel outil de gestion de monorepo est décrit comme une alternative à Nx, souvent utilisé avec PNPM, et dont les exemples sont fournis par Vercel ?",
    options: [
      "Lerna",
      "Turborepo",
      "Yarn"
    ],
    reponse: "Turborepo",
    type: "qcm",
    explication: "Turborepo, développé par Vercel, est un outil de gestion de monorepo mentionné comme une alternative à Nx. Il est souvent utilisé pour faciliter le partage de code et de types TypeScript entre les projets front-end et back-end [24, 25]."
  },
  {
    id: "typescript-16",
    titre: "16️⃣ Immuabilité des propriétés",
    code: "Quel mot-clé de modification de propriété doit être utilisé dans un Type Mappé (`Mapped Type`) pour créer une version immuable d'un type en rendant toutes ses propriétés non modifiables ?",
    options: [],
    reponse: "readonly",
    type: "input",
    explication: "Pour rendre toutes les propriétés d'un type immuables, on utilise le modificateur `readonly` dans le Type Mappé, comme dans l'exemple `Immutable<T> = { readonly [K in keyof T]: T[K]; };` [26, 27]."
  },
  {
    id: "typescript-17",
    titre: "17️⃣ Fonction du Circuit Breaker",
    code: "Quel est l'objectif principal du Circuit Breaker Pattern (Patron Coupe-Circuit) ?",
    options: [
      "Gérer le routage dynamique basé sur les conditions de type au moment de l'exécution.",
      "Empêcher le système de tenter de manière répétée une opération susceptible d'échouer, préservant ainsi l'intégrité du système.",
      "Fournir une réplication de données entre une source primaire et des réplicas."
    ],
    reponse: "Empêcher le système de tenter de manière répétée une opération susceptible d'échouer, préservant ainsi l'intégrité du système.",
    type: "qcm",
    explication: "Le Patron Coupe-Circuit empêche un système d'essayer à plusieurs reprises d'effectuer une opération qui échouerait probablement, ce qui aide à préserver l'intégrité globale du système [28]."
  },
  {
    id: "typescript-18",
    titre: "18️⃣ Optimisation V8",
    code: "Quel terme V8 décrit la structure interne utilisée pour optimiser l'accès aux propriétés, et dont la modification (ajout ou suppression de propriétés après la création de l'objet) peut conduire à une 'déoptimisation' ?",
    options: [],
    reponse: "Hidden Classes",
    type: "input",
    explication: "Les **Hidden Classes** (Classes Cachées) sont des structures internes utilisées par V8 pour optimiser l'accès aux propriétés. Changer la 'forme' d'un objet (ajouter ou supprimer des propriétés après sa création) est une pratique à éviter, car cela peut entraîner une déoptimisation du code, le ramenant à des chemins d'exécution plus lents [29]."
  },
  {
    id: "typescript-19",
    titre: "19️⃣ Union Discriminée (Discriminated Unions)",
    code: "Comment les Unions Discriminées (Discriminated Unions) modélisent-elles des structures de données complexes de manière sécurisée en TypeScript ?",
    options: [
      "Elles s'assurent que tous les types fusionnés sont optionnels.",
      "Elles utilisent une propriété commune (le discriminant) pour différencier les différents types au sein de l'union.",
      "Elles garantissent que tous les objets sont des Singletons."
    ],
    reponse: "Elles utilisent une propriété commune (le discriminant) pour différencier les différents types au sein de l'union.",
    type: "qcm",
    explication: "Les Unions Discriminées (aussi appelées tagged unions) utilisent une propriété commune, appelée le discriminant, pour distinguer les différents types possibles au sein de l'union. Ceci permet de gérer des formes de données variables de manière *type-safe* [30]."
  },
  {
    id: "typescript-20",
    titre: "20️⃣ Couche Infrastructure DDD",
    code: "Selon l'organisation en couches suggérée par le Domain-Driven Design (DDD), quelle couche est responsable de contenir les implémentations concrètes des classes de repository (comme `MySQLCompetitionRepository`) et tout autre composant dépendant du contexte réel de l'application ?",
    options: [],
    reponse: "Infrastructure",
    type: "input",
    explication: "Les couches DDD les plus couramment utilisées incluent la couche **Infrastructure**, qui contient l'implémentation des classes de repository et d'autres composants dépendants du contexte (comme les courtiers de messages) [31]."
  },
  {
    id: "typescript-21",
    titre: "21️⃣ Patron Client-Serveur",
    code: "Dans le Patron Client-Serveur, quel est le rôle du 'Client' ?",
    options: [
      "Il fournit des services et gère la logique métier.",
      "Il compile le code machine.",
      "Il consomme les services fournis par le serveur."
    ],
    reponse: "Il consomme les services fournis par le serveur.",
    type: "qcm",
    explication: "Le Patron Client-Serveur est similaire à la relation classique client-serveur dans un restaurant. Le serveur fournit des services, et les clients les consomment, ce qui sépare les préoccupations, améliore l'évolutivité et la maintenance [32]."
  },
  {
    id: "typescript-22",
    titre: "22️⃣ Déclaration de Variable à éviter",
    code: "Quel mot-clé de déclaration de variable JavaScript est généralement déconseillé en raison de sa portée plus large, qui peut entraîner des variables globales non intentionnelles et des problèmes de gestion de la mémoire ?",
    options: [],
    reponse: "var",
    type: "input",
    explication: "Il est recommandé d'utiliser `const` ou `let` et d'éviter d'utiliser `var`, car ce dernier peut entraîner des variables globales involontaires en raison de sa portée plus large, ce qui peut contribuer aux fuites de mémoire s'il est mal géré [14]."
  },
  {
    id: "typescript-23",
    titre: "23️⃣ Types Littéraux de Modèle",
    code: "Quel avantage majeur les Types Littéraux de Modèle (Template Literal Types) offrent-ils en TypeScript ?",
    options: [
      "Ils permettent de créer des types qui représentent des structures de données récursives.",
      "Ils permettent de construire de nouveaux types de chaînes de caractères en combinant des littéraux de chaînes et des expressions dynamiques pour une vérification de type string plus stricte.",
      "Ils sont utilisés pour la modélisation de types conditionnels complexes."
    ],
    reponse: "Ils permettent de construire de nouveaux types de chaînes de caractères en combinant des littéraux de chaînes et des expressions dynamiques pour une vérification de type string plus stricte.",
    type: "qcm",
    explication: "Les Template Literal Types permettent de construire de nouveaux types de chaînes de caractères en combinant des littéraux de chaînes et des expressions dynamiques. Cela est utile pour, par exemple, définir des types stricts pour les chemins d'API (`/users/${number}`) [33]."
  },
  {
    id: "typescript-24",
    titre: "24️⃣ Objectif du Singleton",
    code: "Quel est le but principal du patron de conception Singleton ?",
    options: [
      "Assurer qu'un objet possède une interface identique à un autre objet.",
      "Assurer qu'une classe n'a qu'une seule instance et fournir un point d'accès global à celle-ci.",
      "Permettre aux objets de s'abonner et de recevoir des notifications d'un sujet."
    ],
    reponse: "Assurer qu'une classe n'a qu'une seule instance et fournir un point d'accès global à celle-ci.",
    type: "qcm",
    explication: "Le patron Singleton est un patron de conception qui garantit qu'une classe n'a qu'une seule instance et fournit un point d'accès global à cette instance tout au long de la durée de vie de l'application. En JavaScript, il peut être implémenté en utilisant la classe `Proxy` avec un gestionnaire `construct` [34, 35]."
  },
  {
    id: "typescript-25",
    titre: "25️⃣ Organisation Monorepo NPM",
    code: "Quel terme est utilisé dans l'écosystème NPM (et Yarn/PNPM) pour organiser plusieurs packages dans un seul dépôt, permettant de référencer directement les dépendances internes, notamment pour partager des types TypeScript ?",
    options: [],
    reponse: "Workspaces",
    type: "input",
    explication: "Les **Workspaces** (Espaces de travail) avec NPM, Yarn ou PNPM sont suffisants pour gérer un monorepo, permettant à un front-end de dépendre directement d'un package 'common' ou 'backend' pour le partage de code et de types TypeScript [25, 36, 37]."
  },
  {
    id: "typescript-26",
    titre: "26️⃣ Centralisation du Domaine",
    code: "Dans une application moderne avec un front-end et un back-end, où est-il souvent préférable de centraliser le modèle de domaine lorsque la complexité de la logique métier est élevée, selon les pratiques de DDD ?",
    options: [
      "Dans le Micro-frontend.",
      "Dans le Backend.",
      "Dans une couche commune partagée (common layer)."
    ],
    reponse: "Dans le Backend.",
    type: "qcm",
    explication: "Dans les projets avec une logique métier complexe, il est souvent préférable de centraliser le modèle de domaine dans le **backend**. Le front-end peut ensuite utiliser des sous-domaines (projections) dédiés pour éviter de contenir la logique métier [38]."
  },
  {
    id: "typescript-27",
    titre: "27️⃣ Structures de Données V8",
    code: "Pourquoi est-il conseillé d'utiliser `Map` et `Set` plutôt que de simples objets ou tableaux pour certaines collections, lorsque l'on optimise le code JavaScript pour le moteur V8 ?",
    options: [
      "Ils sont plus faciles à sérialiser en JSON.",
      "Ils fournissent de meilleures performances pour certaines opérations, telles que les recherches de clé-valeur efficaces, que les objets standards.",
      "Ils peuvent être facilement transformés en WebAssembly."
    ],
    reponse: "Ils fournissent de meilleures performances pour certaines opérations, telles que les recherches de clé-valeur efficaces, que les objets standards.",
    type: "qcm",
    explication: "Il est recommandé d'utiliser des structures de données efficaces comme `Map` et `Set` pour les collections, car elles offrent de meilleures performances pour certaines opérations par rapport aux objets simples et aux tableaux [39]."
  },
  {
    id: "typescript-28",
    titre: "28️⃣ Tolérance aux pannes de Données",
    code: "Le patron Primary-Replica (Primaire-Réplica) gère la réplication des données et leur distribution. Quel bénéfice clé apporte-t-il, en plus de l'équilibrage de charge ?",
    options: [],
    reponse: "tolérance-aux-pannes",
    type: "input",
    explication: "Le patron Primary-Replica permet la réplication et la distribution des données, ce qui permet l'équilibrage de charge et la **tolérance aux pannes** (fault tolerance) en maintenant plusieurs réplicas des mêmes données [40]."
  },
  {
    id: "typescript-29",
    titre: "29️⃣ Utilité des Types Récursifs",
    code: "À quoi servent les Types Récursifs en TypeScript ?",
    options: [
      "À définir des fonctions génériques avec des arguments variables.",
      "À créer des structures de données complexes auto-référentes, comme des listes chaînées ou des arbres.",
      "À manipuler les modificateurs de propriétés (comme `readonly` et `?`)."
    ],
    reponse: "À créer des structures de données complexes auto-référentes, comme des listes chaînées ou des arbres.",
    type: "qcm",
    explication: "Les Types Récursifs sont des types qui se référencent eux-mêmes et permettent la définition de structures de données complexes, telles qu'une liste chaînée (`LinkedList<T>`) [18]."
  },
  {
    id: "typescript-30",
    titre: "30️⃣ Patron de Médiation",
    code: "En raison de sa position entre le client et l'objet réel, le patron Proxy est parfois catégorisé ou référé sous le nom d'un autre patron de conception. Quel est ce nom ? (Un seul mot)",
    options: [],
    reponse: "Mediator",
    type: "input",
    explication: "Étant donné que le proxy se situe entre le client d'un objet et l'objet lui-même et peut choisir d'agir comme un 'protecteur' ou d'ajouter une logique personnalisée, il peut parfois être appelé **Mediator** (Médiateur) [41]."
  },
  {
    id: "typescript-31",
    titre: "31️⃣ Prévention des Références Circulaires",
    code: "Quelle structure de données JavaScript est recommandée comme meilleure pratique pour la gestion de la mémoire, car elle est automatiquement collectée par le ramasse-miettes et peut aider à prévenir les références circulaires ?",
    options: [
      "Les tableaux (Arrays).",
      "WeakMap et WeakSet.",
      "Les objets standards `{}`."
    ],
    reponse: "WeakMap et WeakSet.",
    type: "qcm",
    explication: "L'utilisation de **WeakMap** et **WeakSet** est une pratique recommandée car ces structures de données sont automatiquement collectées par le ramasse-miettes, ce qui peut aider à prévenir les références circulaires et les fuites de mémoire [14]."
  },
  {
    id: "typescript-32",
    titre: "32️⃣ Rôle de la Factory en DDD",
    code: "Dans le Domain-Driven Design (DDD), quel type de composant est destiné à créer une seule entité ou un groupe d'entités, tout en masquant les détails d'initialisation aux utilisateurs ?",
    options: [],
    reponse: "Factories",
    type: "input",
    explication: "Les **Factories** (Usines) sont des composants qui modélisent la création d'une seule entité ou d'un groupe d'entités, masquant les détails d'initialisation complexes aux utilisateurs [16]."
  }
];

console.log(quizData);
</script>

<script src="cookie-manager.js"></script>
<script src="quiz-common.js"></script>
<script>
// Initialiser le quiz avec les fonctions communes
const quiz = new QuizManager('quizContainer', quizData, {
    pageId: 'typescript' // ID unique pour cette page
});
</script>

<script src="navigation.js"></script>
<script>
  // Initialiser la navigation pour la page TypeScript
  createNavigation('typescript');
</script>

</body>
</html>